{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NATS Request Many","text":"<p>This is not an official NATS project</p> <p>This is a personal project and is not endorsed by the NATS.io community. It is not guaranteed to be maintained or supported.</p> <p>This is an experimental project</p> <p>This project is a prototype and should not be used for anything serious. It is not tested, nor is it guaranteed to be correct.</p> <p>The nats.deno package (Deno client for NATS) provides a simple way to request many responses from a singe NATS request.</p> <p>This project is an attempt to implement the same API in Python.</p>"},{"location":"#references","title":"References","text":"<ul> <li> <p>The reference document I've used is this PR (not merged at the moment) ADR-??: Request Many.</p> </li> <li> <p>The reference implementation is in the nats.deno package.</p> </li> </ul>"},{"location":"#how-to-install","title":"How to install","text":"pip install git+https://github.com/charbonnierg/nats-request-many.git"},{"location":"#example-usage","title":"Example usage","text":"examples/minimal.py<pre><code>from nats_contrib.request_many import Client\nfrom nats.aio.msg import Msg\n\nimport logging\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\n\nlogger = logging.getLogger(\"request_many\")\n\n\nasync def main():\n    nc = Client()\n    await nc.connect(servers=\"nats://localhost:4222\")\n\n    # Subscription callback\n    async def cb1(msg: Msg):\n        logger.info(f\"sub1 received a message sub1 on {msg.subject}\")\n        await msg.respond(b\"OK\")\n\n    async def cb2(msg: Msg):\n        logger.info(f\"sub2 received a message on {msg.subject}\")\n        await msg.respond(b\"OK\")\n\n    # First subscription\n    sub1 = await nc.subscribe(\"foo\", cb=cb1, queue=\"queue-1\")\n    # Second subscription\n    sub2 = await nc.subscribe(\"foo\", cb=cb2, queue=\"queue-2\")\n\n    # Request many\n    logger.info(\"sending request to subject 'foo'\")\n    msgs = await nc.request_many(\"foo\", b\"help\", max_count=2)\n    for msg in msgs:\n        print(f\"Received a reply: {msg.data.decode()}\")\n\n    # Request many with async iterator\n    logger.info(\"sending request to subject 'foo'\")\n    async with nc.request_many_iter(\"foo\", b\"help\", max_count=2) as msgs:\n        async for msg in msgs:\n            print(f\"Received a reply: {msg.data.decode()}\")\n\n    # Unsubscribe\n    await sub1.unsubscribe()\n    await sub2.unsubscribe()\n\n    # Close\n    await nc.close()\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre> <p>Run the script using:</p> python examples/minimal.py2024-02-21 03:05:16,759 - request_many - INFO - sending request to subject 'foo'2024-02-21 03:05:16,760 - request_many - INFO - sub1 received a message sub1 on foo2024-02-21 03:05:16,760 - request_many - INFO - sub2 received a message on fooReceived a reply: OKReceived a reply: OK2024-02-21 03:05:16,761 - request_many - INFO - sending request to subject 'foo'2024-02-21 03:05:16,762 - request_many - INFO - sub1 received a message sub1 on foo2024-02-21 03:05:16,762 - request_many - INFO - sub2 received a message on fooReceived a reply: OKReceived a reply: OK"},{"location":"#other-works","title":"Other works","text":""},{"location":"#nats-request-many_1","title":"NATS Request Many","text":"<p>This is not an official NATS project</p> <p>This is a personal project and is not endorsed by the NATS.io community. It is not guaranteed to be maintained or supported.</p> <p>This is an experimental project</p> <p>This project is a prototype and should not be used for anything serious. It is not tested, nor is it guaranteed to be correct.</p> <p>The nats.deno package (Deno client for NATS) provides a simple way to request many responses from a singe NATS request.</p> <p>This project is an attempt to implement the same API in Python.</p>"},{"location":"#references_1","title":"References","text":"<ul> <li> <p>The reference document I've used is this PR (not merged at the moment) ADR-??: Request Many.</p> </li> <li> <p>The reference implementation is in the nats.deno package.</p> </li> </ul>"},{"location":"#how-to-install_1","title":"How to install","text":"pip install git+https://github.com/charbonnierg/nats-request-many.git"},{"location":"#example-usage_1","title":"Example usage","text":"examples/minimal.py<pre><code>from nats_contrib.request_many import Client\nfrom nats.aio.msg import Msg\n\nimport logging\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\n\nlogger = logging.getLogger(\"request_many\")\n\n\nasync def main():\n    nc = Client()\n    await nc.connect(servers=\"nats://localhost:4222\")\n\n    # Subscription callback\n    async def cb1(msg: Msg):\n        logger.info(f\"sub1 received a message sub1 on {msg.subject}\")\n        await msg.respond(b\"OK\")\n\n    async def cb2(msg: Msg):\n        logger.info(f\"sub2 received a message on {msg.subject}\")\n        await msg.respond(b\"OK\")\n\n    # First subscription\n    sub1 = await nc.subscribe(\"foo\", cb=cb1, queue=\"queue-1\")\n    # Second subscription\n    sub2 = await nc.subscribe(\"foo\", cb=cb2, queue=\"queue-2\")\n\n    # Request many\n    logger.info(\"sending request to subject 'foo'\")\n    msgs = await nc.request_many(\"foo\", b\"help\", max_count=2)\n    for msg in msgs:\n        print(f\"Received a reply: {msg.data.decode()}\")\n\n    # Request many with async iterator\n    logger.info(\"sending request to subject 'foo'\")\n    async with nc.request_many_iter(\"foo\", b\"help\", max_count=2) as msgs:\n        async for msg in msgs:\n            print(f\"Received a reply: {msg.data.decode()}\")\n\n    # Unsubscribe\n    await sub1.unsubscribe()\n    await sub2.unsubscribe()\n\n    # Close\n    await nc.close()\n\n\nif __name__ == \"__main__\":\n    import asyncio\n\n    asyncio.run(main())\n</code></pre> <p>Run the script using:</p> python examples/minimal.py2024-02-21 03:05:16,759 - request_many - INFO - sending request to subject 'foo'2024-02-21 03:05:16,760 - request_many - INFO - sub1 received a message sub1 on foo2024-02-21 03:05:16,760 - request_many - INFO - sub2 received a message on fooReceived a reply: OKReceived a reply: OK2024-02-21 03:05:16,761 - request_many - INFO - sending request to subject 'foo'2024-02-21 03:05:16,762 - request_many - INFO - sub1 received a message sub1 on foo2024-02-21 03:05:16,762 - request_many - INFO - sub2 received a message on fooReceived a reply: OKReceived a reply: OK"},{"location":"#other-works_1","title":"Other works","text":"<ul> <li> <p>NATS Micro</p> </li> <li> <p>NATS Connect Opts</p> </li> </ul>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Guillaume Charbonnier</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Reference</li> <li>License</li> </ul>"},{"location":"reference/nats_contrib/request_many/","title":"Reference","text":""},{"location":"reference/nats_contrib/request_many/#nats_contrib.request_many.Client","title":"<code>Client</code>","text":"<p>             Bases: <code>Client</code></p> Source code in <code>src/nats_contrib/request_many/client.py</code> <pre><code>class Client(NATSClient):\n    def __init__(\n        self,\n        max_wait: float = 0.5,\n    ) -&gt; None:\n        super().__init__()\n        self.max_wait = max_wait\n\n    def request_many_iter(\n        self,\n        subject: str,\n        payload: bytes | None = None,\n        headers: dict[str, str] | None = None,\n        reply_inbox: str | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n        stop_on_sentinel: bool = False,\n    ) -&gt; AsyncContextManager[AsyncIterator[Msg]]:\n        \"\"\"Request many responses from the same subject.\n\n        The iterator exits without raising an error when no responses are received.\n\n        Responses are received until one of the following conditions is met:\n\n        - max_wait seconds have passed.\n        - max_count responses have been received.\n        - max_interval seconds have passed between responses.\n        - A sentinel message is received and stop_on_sentinel is True.\n\n        When any of the condition is met, the async iterator yielded by the\n        context manager raises StopAsyncIteration on the next iteration.\n\n        The subscription is started when entering the async context manager and\n        stopped when exiting.\n\n        Args:\n            subject: The subject to send the request to.\n            payload: The payload to send with the request.\n            headers: The headers to send with the request.\n            reply_inbox: The inbox to receive the responses in. A new inbox is created if None.\n            max_wait: The maximum amount of time to wait for responses. 1 second by default.\n            max_count: The maximum number of responses to accept. No limit by default.\n            max_interval: The maximum amount of time between responses. No limit by default.\n            stop_on_sentinel: Whether to stop when a sentinel message is received. False by default.\n        \"\"\"\n        inbox = reply_inbox or self.new_inbox()\n        return RequestManyIterator(\n            self,\n            subject,\n            payload=payload,\n            headers=headers,\n            inbox=inbox,\n            max_wait=max_wait,\n            max_count=max_count,\n            max_interval=max_interval,\n            stop_on_sentinel=stop_on_sentinel,\n        )\n\n    async def request_many(\n        self,\n        subject: str,\n        payload: bytes | None = None,\n        headers: dict[str, str] | None = None,\n        reply_inbox: str | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n        stop_on_sentinel: bool = False,\n    ) -&gt; list[Msg]:\n        \"\"\"Request many responses from the same subject.\n\n        This function does not raise an error when no responses are received.\n\n        Responses are received until one of the following conditions is met:\n\n        - max_wait seconds have passed.\n        - max_count responses have been received.\n        - max_interval seconds have passed between responses.\n        - A sentinel message is received and stop_on_sentinel is True.\n\n        Subscription is always stopped when the function returns.\n\n        Args:\n            subject: The subject to send the request to.\n            payload: The payload to send with the request.\n            headers: The headers to send with the request.\n            reply_inbox: The inbox to receive the responses in. A new inbox is created if None.\n            max_wait: The maximum amount of time to wait for responses. 1 second by default.\n            max_count: The maximum number of responses to accept. No limit by default.\n            max_interval: The maximum amount of time between responses. No limit by default.\n            stop_on_sentinel: Whether to stop when a sentinel message is received. False by default.\n        \"\"\"\n        executor = RequestManyExecutor(self, max_wait)\n        return await executor(\n            subject,\n            reply_inbox=reply_inbox,\n            payload=payload,\n            headers=headers,\n            max_wait=max_wait,\n            max_count=max_count,\n            max_interval=max_interval,\n            stop_on_sentinel=stop_on_sentinel,\n        )\n</code></pre>"},{"location":"reference/nats_contrib/request_many/#nats_contrib.request_many.Client.request_many","title":"<code>request_many(subject, payload=None, headers=None, reply_inbox=None, max_wait=None, max_count=None, max_interval=None, stop_on_sentinel=False)</code>  <code>async</code>","text":"<p>Request many responses from the same subject.</p> <p>This function does not raise an error when no responses are received.</p> <p>Responses are received until one of the following conditions is met:</p> <ul> <li>max_wait seconds have passed.</li> <li>max_count responses have been received.</li> <li>max_interval seconds have passed between responses.</li> <li>A sentinel message is received and stop_on_sentinel is True.</li> </ul> <p>Subscription is always stopped when the function returns.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>The subject to send the request to.</p> required <code>payload</code> <code>bytes | None</code> <p>The payload to send with the request.</p> <code>None</code> <code>headers</code> <code>dict[str, str] | None</code> <p>The headers to send with the request.</p> <code>None</code> <code>reply_inbox</code> <code>str | None</code> <p>The inbox to receive the responses in. A new inbox is created if None.</p> <code>None</code> <code>max_wait</code> <code>float | None</code> <p>The maximum amount of time to wait for responses. 1 second by default.</p> <code>None</code> <code>max_count</code> <code>int | None</code> <p>The maximum number of responses to accept. No limit by default.</p> <code>None</code> <code>max_interval</code> <code>float | None</code> <p>The maximum amount of time between responses. No limit by default.</p> <code>None</code> <code>stop_on_sentinel</code> <code>bool</code> <p>Whether to stop when a sentinel message is received. False by default.</p> <code>False</code> Source code in <code>src/nats_contrib/request_many/client.py</code> <pre><code>async def request_many(\n    self,\n    subject: str,\n    payload: bytes | None = None,\n    headers: dict[str, str] | None = None,\n    reply_inbox: str | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n    stop_on_sentinel: bool = False,\n) -&gt; list[Msg]:\n    \"\"\"Request many responses from the same subject.\n\n    This function does not raise an error when no responses are received.\n\n    Responses are received until one of the following conditions is met:\n\n    - max_wait seconds have passed.\n    - max_count responses have been received.\n    - max_interval seconds have passed between responses.\n    - A sentinel message is received and stop_on_sentinel is True.\n\n    Subscription is always stopped when the function returns.\n\n    Args:\n        subject: The subject to send the request to.\n        payload: The payload to send with the request.\n        headers: The headers to send with the request.\n        reply_inbox: The inbox to receive the responses in. A new inbox is created if None.\n        max_wait: The maximum amount of time to wait for responses. 1 second by default.\n        max_count: The maximum number of responses to accept. No limit by default.\n        max_interval: The maximum amount of time between responses. No limit by default.\n        stop_on_sentinel: Whether to stop when a sentinel message is received. False by default.\n    \"\"\"\n    executor = RequestManyExecutor(self, max_wait)\n    return await executor(\n        subject,\n        reply_inbox=reply_inbox,\n        payload=payload,\n        headers=headers,\n        max_wait=max_wait,\n        max_count=max_count,\n        max_interval=max_interval,\n        stop_on_sentinel=stop_on_sentinel,\n    )\n</code></pre>"},{"location":"reference/nats_contrib/request_many/#nats_contrib.request_many.Client.request_many_iter","title":"<code>request_many_iter(subject, payload=None, headers=None, reply_inbox=None, max_wait=None, max_count=None, max_interval=None, stop_on_sentinel=False)</code>","text":"<p>Request many responses from the same subject.</p> <p>The iterator exits without raising an error when no responses are received.</p> <p>Responses are received until one of the following conditions is met:</p> <ul> <li>max_wait seconds have passed.</li> <li>max_count responses have been received.</li> <li>max_interval seconds have passed between responses.</li> <li>A sentinel message is received and stop_on_sentinel is True.</li> </ul> <p>When any of the condition is met, the async iterator yielded by the context manager raises StopAsyncIteration on the next iteration.</p> <p>The subscription is started when entering the async context manager and stopped when exiting.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>The subject to send the request to.</p> required <code>payload</code> <code>bytes | None</code> <p>The payload to send with the request.</p> <code>None</code> <code>headers</code> <code>dict[str, str] | None</code> <p>The headers to send with the request.</p> <code>None</code> <code>reply_inbox</code> <code>str | None</code> <p>The inbox to receive the responses in. A new inbox is created if None.</p> <code>None</code> <code>max_wait</code> <code>float | None</code> <p>The maximum amount of time to wait for responses. 1 second by default.</p> <code>None</code> <code>max_count</code> <code>int | None</code> <p>The maximum number of responses to accept. No limit by default.</p> <code>None</code> <code>max_interval</code> <code>float | None</code> <p>The maximum amount of time between responses. No limit by default.</p> <code>None</code> <code>stop_on_sentinel</code> <code>bool</code> <p>Whether to stop when a sentinel message is received. False by default.</p> <code>False</code> Source code in <code>src/nats_contrib/request_many/client.py</code> <pre><code>def request_many_iter(\n    self,\n    subject: str,\n    payload: bytes | None = None,\n    headers: dict[str, str] | None = None,\n    reply_inbox: str | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n    stop_on_sentinel: bool = False,\n) -&gt; AsyncContextManager[AsyncIterator[Msg]]:\n    \"\"\"Request many responses from the same subject.\n\n    The iterator exits without raising an error when no responses are received.\n\n    Responses are received until one of the following conditions is met:\n\n    - max_wait seconds have passed.\n    - max_count responses have been received.\n    - max_interval seconds have passed between responses.\n    - A sentinel message is received and stop_on_sentinel is True.\n\n    When any of the condition is met, the async iterator yielded by the\n    context manager raises StopAsyncIteration on the next iteration.\n\n    The subscription is started when entering the async context manager and\n    stopped when exiting.\n\n    Args:\n        subject: The subject to send the request to.\n        payload: The payload to send with the request.\n        headers: The headers to send with the request.\n        reply_inbox: The inbox to receive the responses in. A new inbox is created if None.\n        max_wait: The maximum amount of time to wait for responses. 1 second by default.\n        max_count: The maximum number of responses to accept. No limit by default.\n        max_interval: The maximum amount of time between responses. No limit by default.\n        stop_on_sentinel: Whether to stop when a sentinel message is received. False by default.\n    \"\"\"\n    inbox = reply_inbox or self.new_inbox()\n    return RequestManyIterator(\n        self,\n        subject,\n        payload=payload,\n        headers=headers,\n        inbox=inbox,\n        max_wait=max_wait,\n        max_count=max_count,\n        max_interval=max_interval,\n        stop_on_sentinel=stop_on_sentinel,\n    )\n</code></pre>"},{"location":"reference/nats_contrib/request_many/#nats_contrib.request_many.RequestManyExecutor","title":"<code>RequestManyExecutor</code>","text":"Source code in <code>src/nats_contrib/request_many/executor.py</code> <pre><code>class RequestManyExecutor:\n    def __init__(\n        self,\n        nc: Client,\n        max_wait: float | None = None,\n    ) -&gt; None:\n        self.nc = nc\n        self.max_wait = max_wait or 0.5\n\n    async def __call__(\n        self,\n        subject: str,\n        reply_inbox: str | None = None,\n        payload: bytes | None = None,\n        headers: dict[str, str] | None = None,\n        max_wait: float | None = None,\n        max_count: int | None = None,\n        max_interval: float | None = None,\n        stop_on_sentinel: bool = False,\n    ) -&gt; list[Msg]:\n        \"\"\"Request many responses from the same subject.\n\n        This function does not raise an error when no responses are received.\n\n        Responses are received until one of the following conditions is met:\n\n        - max_wait seconds have passed.\n        - max_count responses have been received.\n        - max_interval seconds have passed between responses.\n        - A sentinel message is received and stop_on_sentinel is True.\n\n        Args:\n            subject: The subject to send the request to.\n            payload: The payload to send with the request.\n            headers: The headers to send with the request.\n            reply_inbox: The inbox to receive the responses in. A new inbox is created if None.\n            max_wait: The maximum amount of time to wait for responses. Default max wait can be configured at the instance level.\n            max_count: The maximum number of responses to accept. No limit by default.\n            max_interval: The maximum amount of time between responses. No limit by default.\n            stop_on_sentinel: Whether to stop when a sentinel message is received. False by default.\n        \"\"\"\n        if max_wait is None and max_interval is None:\n            max_wait = self.max_wait\n        # Create an inbox for the responses if one wasn't provided.\n        if reply_inbox is None:\n            reply_inbox = self.nc.new_inbox()\n        # Create an empty list to store the responses.\n        responses: list[Msg] = []\n        # Get the event loop\n        loop = asyncio.get_event_loop()\n        # Create an event to signal when the request is complete.\n        event = asyncio.Event()\n        # Create a marker to indicate that a message was received\n        # and the interval has passed.\n        last_received = loop.time()\n\n        # Define a callback to handle the responses.\n        async def callback(msg: Msg) -&gt; None:\n            # Update the last received time.\n            nonlocal last_received\n            last_received = loop.time()\n            # If we're stopping on a sentinel message, check for it\n            # and don't append the message to the list of responses.\n            if stop_on_sentinel and msg.data == b\"\":\n                event.set()\n                return\n            # In all other cases, append the message to the list of responses.\n            responses.append(msg)\n            # And check if we've received all the responses.\n            if len(responses) == max_count:\n                event.set()\n\n        # Subscribe to the inbox.\n        sub = await self.nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n            reply_inbox,\n            cb=callback,\n            max_msgs=max_count or 0,\n        )\n        # Initialize a list of tasks to wait for.\n        tasks: list[asyncio.Task[object]] = []\n        # Enter try/finally clause to ensure that the subscription is\n        # unsubscribed from even if an error occurs.\n        try:\n            # Create task to wait for the stop event.\n            tasks.append(asyncio.create_task(event.wait()))\n\n            # Add a task to wait for the max_wait time if needed\n            if max_wait:\n                tasks.append(asyncio.create_task(asyncio.sleep(max_wait)))\n\n            # Add a task to check the interval if needed\n            if max_interval:\n\n                async def check_interval() -&gt; None:\n                    nonlocal last_received\n                    while True:\n                        await asyncio.sleep(max_interval)\n                        if loop.time() - last_received &gt; max_interval:\n                            event.set()\n                            return\n\n                tasks.append(asyncio.create_task(check_interval()))\n\n            # At this point the subscription is ready and all tasks are submitted\n            # Publish the request.\n            await self.nc.publish(subject, payload or b\"\", reply=reply_inbox, headers=headers)\n            # Wait for the first task to complete.\n            await asyncio.wait(\n                tasks,\n                return_when=asyncio.FIRST_COMPLETED,\n            )\n        # Always cancel tasks and unsubscribe from the inbox.\n        finally:\n            # Cancel the remaining tasks as soon as first one completes.\n            for task in tasks:\n                if not task.done():\n                    task.cancel()\n            # Unsubscribe from the inbox.\n            try:\n                await sub.unsubscribe()\n            except BadSubscriptionError:\n                # It's possible that auto-unsubscribe has already been called.\n                pass\n\n        # Return the list of responses.\n        return responses\n</code></pre>"},{"location":"reference/nats_contrib/request_many/#nats_contrib.request_many.RequestManyExecutor.__call__","title":"<code>__call__(subject, reply_inbox=None, payload=None, headers=None, max_wait=None, max_count=None, max_interval=None, stop_on_sentinel=False)</code>  <code>async</code>","text":"<p>Request many responses from the same subject.</p> <p>This function does not raise an error when no responses are received.</p> <p>Responses are received until one of the following conditions is met:</p> <ul> <li>max_wait seconds have passed.</li> <li>max_count responses have been received.</li> <li>max_interval seconds have passed between responses.</li> <li>A sentinel message is received and stop_on_sentinel is True.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>The subject to send the request to.</p> required <code>payload</code> <code>bytes | None</code> <p>The payload to send with the request.</p> <code>None</code> <code>headers</code> <code>dict[str, str] | None</code> <p>The headers to send with the request.</p> <code>None</code> <code>reply_inbox</code> <code>str | None</code> <p>The inbox to receive the responses in. A new inbox is created if None.</p> <code>None</code> <code>max_wait</code> <code>float | None</code> <p>The maximum amount of time to wait for responses. Default max wait can be configured at the instance level.</p> <code>None</code> <code>max_count</code> <code>int | None</code> <p>The maximum number of responses to accept. No limit by default.</p> <code>None</code> <code>max_interval</code> <code>float | None</code> <p>The maximum amount of time between responses. No limit by default.</p> <code>None</code> <code>stop_on_sentinel</code> <code>bool</code> <p>Whether to stop when a sentinel message is received. False by default.</p> <code>False</code> Source code in <code>src/nats_contrib/request_many/executor.py</code> <pre><code>async def __call__(\n    self,\n    subject: str,\n    reply_inbox: str | None = None,\n    payload: bytes | None = None,\n    headers: dict[str, str] | None = None,\n    max_wait: float | None = None,\n    max_count: int | None = None,\n    max_interval: float | None = None,\n    stop_on_sentinel: bool = False,\n) -&gt; list[Msg]:\n    \"\"\"Request many responses from the same subject.\n\n    This function does not raise an error when no responses are received.\n\n    Responses are received until one of the following conditions is met:\n\n    - max_wait seconds have passed.\n    - max_count responses have been received.\n    - max_interval seconds have passed between responses.\n    - A sentinel message is received and stop_on_sentinel is True.\n\n    Args:\n        subject: The subject to send the request to.\n        payload: The payload to send with the request.\n        headers: The headers to send with the request.\n        reply_inbox: The inbox to receive the responses in. A new inbox is created if None.\n        max_wait: The maximum amount of time to wait for responses. Default max wait can be configured at the instance level.\n        max_count: The maximum number of responses to accept. No limit by default.\n        max_interval: The maximum amount of time between responses. No limit by default.\n        stop_on_sentinel: Whether to stop when a sentinel message is received. False by default.\n    \"\"\"\n    if max_wait is None and max_interval is None:\n        max_wait = self.max_wait\n    # Create an inbox for the responses if one wasn't provided.\n    if reply_inbox is None:\n        reply_inbox = self.nc.new_inbox()\n    # Create an empty list to store the responses.\n    responses: list[Msg] = []\n    # Get the event loop\n    loop = asyncio.get_event_loop()\n    # Create an event to signal when the request is complete.\n    event = asyncio.Event()\n    # Create a marker to indicate that a message was received\n    # and the interval has passed.\n    last_received = loop.time()\n\n    # Define a callback to handle the responses.\n    async def callback(msg: Msg) -&gt; None:\n        # Update the last received time.\n        nonlocal last_received\n        last_received = loop.time()\n        # If we're stopping on a sentinel message, check for it\n        # and don't append the message to the list of responses.\n        if stop_on_sentinel and msg.data == b\"\":\n            event.set()\n            return\n        # In all other cases, append the message to the list of responses.\n        responses.append(msg)\n        # And check if we've received all the responses.\n        if len(responses) == max_count:\n            event.set()\n\n    # Subscribe to the inbox.\n    sub = await self.nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n        reply_inbox,\n        cb=callback,\n        max_msgs=max_count or 0,\n    )\n    # Initialize a list of tasks to wait for.\n    tasks: list[asyncio.Task[object]] = []\n    # Enter try/finally clause to ensure that the subscription is\n    # unsubscribed from even if an error occurs.\n    try:\n        # Create task to wait for the stop event.\n        tasks.append(asyncio.create_task(event.wait()))\n\n        # Add a task to wait for the max_wait time if needed\n        if max_wait:\n            tasks.append(asyncio.create_task(asyncio.sleep(max_wait)))\n\n        # Add a task to check the interval if needed\n        if max_interval:\n\n            async def check_interval() -&gt; None:\n                nonlocal last_received\n                while True:\n                    await asyncio.sleep(max_interval)\n                    if loop.time() - last_received &gt; max_interval:\n                        event.set()\n                        return\n\n            tasks.append(asyncio.create_task(check_interval()))\n\n        # At this point the subscription is ready and all tasks are submitted\n        # Publish the request.\n        await self.nc.publish(subject, payload or b\"\", reply=reply_inbox, headers=headers)\n        # Wait for the first task to complete.\n        await asyncio.wait(\n            tasks,\n            return_when=asyncio.FIRST_COMPLETED,\n        )\n    # Always cancel tasks and unsubscribe from the inbox.\n    finally:\n        # Cancel the remaining tasks as soon as first one completes.\n        for task in tasks:\n            if not task.done():\n                task.cancel()\n        # Unsubscribe from the inbox.\n        try:\n            await sub.unsubscribe()\n        except BadSubscriptionError:\n            # It's possible that auto-unsubscribe has already been called.\n            pass\n\n    # Return the list of responses.\n    return responses\n</code></pre>"},{"location":"reference/nats_contrib/request_many/#nats_contrib.request_many.RequestManyIterator","title":"<code>RequestManyIterator</code>","text":"Source code in <code>src/nats_contrib/request_many/iterator.py</code> <pre><code>class RequestManyIterator:\n\n    def __init__(\n        self,\n        nc: Client,\n        subject: str,\n        inbox: str,\n        payload: bytes | None = None,\n        headers: dict[str, str] | None = None,\n        max_wait: float | None = None,\n        max_interval: float | None = None,\n        max_count: int | None = None,\n        stop_on_sentinel: bool = False,\n    ) -&gt; None:\n        \"\"\"Request many responses from the same subject.\n\n        Request is sent when entering the async context manager and unsubscribed when exiting.\n\n        The async iterator yieled by the context manager do not raise an\n        error when no responses are received.\n\n        Responses are received until one of the following conditions is met:\n\n        - max_wait seconds have passed.\n        - max_count responses have been received.\n        - max_interval seconds have passed between responses.\n        - A sentinel message is received and stop_on_sentinel is True.\n\n        When any of the condition is met, the async iterator raises StopAsyncIteration on\n        the next call to __anext__, and the subscription is unsubscribed on exit.\n\n        Args:\n            subject: The subject to send the request to.\n            payload: The payload to send with the request.\n            headers: The headers to send with the request.\n            inbox: The inbox to receive the responses in. A new inbox is created if None.\n            max_wait: The maximum amount of time to wait for responses. Default max wait can be configured at the instance level.\n            max_count: The maximum number of responses to accept. No limit by default.\n            max_interval: The maximum amount of time between responses. No limit by default.\n            stop_on_sentinel: Whether to stop when a sentinel message is received. False by default.\n        \"\"\"\n        if max_wait is None and max_interval is None:\n            max_wait = 0.5\n        # Save all the arguments as instance variables.\n        self.nc = nc\n        self.subject = subject\n        self.payload = payload\n        self.headers = headers\n        self.inbox = inbox\n        self.max_wait = max_wait\n        self.max_count = max_count\n        self.max_interval = max_interval\n        self.stop_on_sentinel = stop_on_sentinel\n        # Initialize the state of the request many iterator\n        self._sub: Subscription | None = None\n        self._iterator: AsyncIterator[Msg] | None = None\n        self._did_unsubscribe = False\n        self._total_received = 0\n        self._last_received = asyncio.get_event_loop().time()\n        self._tasks: list[asyncio.Task[object]] = []\n        self._pending_task: asyncio.Task[Msg] | None = None\n\n    def __aiter__(self) -&gt; RequestManyIterator:\n        \"\"\"RequestManyIterator is an asynchronous iterator.\"\"\"\n        return self\n\n    async def __anext__(self) -&gt; Msg:\n        \"\"\"Return the next message or raise StopAsyncIteration.\"\"\"\n        if not self._sub:\n            raise RuntimeError(\n                \"RequestManyIterator must be used as an async context manager\"\n            )\n        # Exit early if we've already unsubscribed\n        if self._did_unsubscribe:\n            raise StopAsyncIteration\n        # Exit early if we received all the messages\n        if self.max_count and self._total_received == self.max_count:\n            if self._sub and not self._did_unsubscribe:\n                self._did_unsubscribe = True\n                await _unsubscribe(self._sub)\n            raise StopAsyncIteration\n        # Create a task to wait for the next message\n        task: asyncio.Task[Msg] = asyncio.create_task(self._iterator.__anext__())  # type: ignore\n        self._pending_task = task\n        # Wait for the next message or any of the other tasks to complete\n        await asyncio.wait(\n            [self._pending_task, *self._tasks],\n            return_when=asyncio.FIRST_COMPLETED,\n        )\n        if self._pending_task.cancelled():\n            raise StopAsyncIteration\n        if not self._pending_task.done():\n            self._pending_task.cancel()\n            raise StopAsyncIteration\n        # if err := self._pending_task.exception():\n        #     raise err\n        # This will raise an exception if an error occurred within the task\n        msg = self._pending_task.result()\n        # Always increment the total received count\n        self._total_received += 1\n        # Check if this is a sentinel message\n        if self.stop_on_sentinel and msg.subject == \"sentinel\":\n            if self._sub and not self._did_unsubscribe:\n                self._did_unsubscribe = True\n                await _unsubscribe(self._sub)\n            # In which case, raise StopAsyncIteration and don't return the message\n            raise StopAsyncIteration\n        # Return the message\n        return msg\n\n    async def __aenter__(self) -&gt; RequestManyIterator:\n        \"\"\"Start the subscription and publish the request.\"\"\"\n        # Start the subscription\n        sub = await self.nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n            self.inbox,\n            max_msgs=self.max_count or 0,\n        )\n        # Save the subscription and the iterator\n        self._iterator = sub.messages\n        self._sub = sub\n        # Add a task to wait for the max_wait time if needed\n        if self.max_wait:\n            self._tasks.append(asyncio.create_task(asyncio.sleep(self.max_wait)))\n        # Add a task to check the interval if needed\n        if self.max_interval:\n            interval = self.max_interval\n\n            async def check_interval() -&gt; None:\n                while True:\n                    await asyncio.sleep(interval)\n                    if asyncio.get_event_loop().time() - self._last_received &gt; interval:\n                        if self._sub and not self._did_unsubscribe:\n                            self._did_unsubscribe = True\n                            await _unsubscribe(self._sub)\n                        return\n\n            self._tasks.append(asyncio.create_task(check_interval()))\n\n        # Publish the request\n        await self.nc.publish(\n            self.subject, self.payload or b\"\", reply=self.inbox, headers=self.headers\n        )\n        # At this point the subscription is ready and all tasks are submitted\n        return self\n\n    async def __aexit__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Unsubscribe from the inbox and cancel all the tasks.\"\"\"\n        for task in self._tasks:\n            if not task.done():\n                task.cancel()\n        if self._pending_task and not self._pending_task.done():\n            self._pending_task.cancel()\n        if self._sub and not self._did_unsubscribe:\n            await _unsubscribe(self._sub)\n</code></pre>"},{"location":"reference/nats_contrib/request_many/#nats_contrib.request_many.RequestManyIterator.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Start the subscription and publish the request.</p> Source code in <code>src/nats_contrib/request_many/iterator.py</code> <pre><code>async def __aenter__(self) -&gt; RequestManyIterator:\n    \"\"\"Start the subscription and publish the request.\"\"\"\n    # Start the subscription\n    sub = await self.nc.subscribe(  # pyright: ignore[reportUnknownMemberType]\n        self.inbox,\n        max_msgs=self.max_count or 0,\n    )\n    # Save the subscription and the iterator\n    self._iterator = sub.messages\n    self._sub = sub\n    # Add a task to wait for the max_wait time if needed\n    if self.max_wait:\n        self._tasks.append(asyncio.create_task(asyncio.sleep(self.max_wait)))\n    # Add a task to check the interval if needed\n    if self.max_interval:\n        interval = self.max_interval\n\n        async def check_interval() -&gt; None:\n            while True:\n                await asyncio.sleep(interval)\n                if asyncio.get_event_loop().time() - self._last_received &gt; interval:\n                    if self._sub and not self._did_unsubscribe:\n                        self._did_unsubscribe = True\n                        await _unsubscribe(self._sub)\n                    return\n\n        self._tasks.append(asyncio.create_task(check_interval()))\n\n    # Publish the request\n    await self.nc.publish(\n        self.subject, self.payload or b\"\", reply=self.inbox, headers=self.headers\n    )\n    # At this point the subscription is ready and all tasks are submitted\n    return self\n</code></pre>"},{"location":"reference/nats_contrib/request_many/#nats_contrib.request_many.RequestManyIterator.__aexit__","title":"<code>__aexit__(*args, **kwargs)</code>  <code>async</code>","text":"<p>Unsubscribe from the inbox and cancel all the tasks.</p> Source code in <code>src/nats_contrib/request_many/iterator.py</code> <pre><code>async def __aexit__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Unsubscribe from the inbox and cancel all the tasks.\"\"\"\n    for task in self._tasks:\n        if not task.done():\n            task.cancel()\n    if self._pending_task and not self._pending_task.done():\n        self._pending_task.cancel()\n    if self._sub and not self._did_unsubscribe:\n        await _unsubscribe(self._sub)\n</code></pre>"},{"location":"reference/nats_contrib/request_many/#nats_contrib.request_many.RequestManyIterator.__aiter__","title":"<code>__aiter__()</code>","text":"<p>RequestManyIterator is an asynchronous iterator.</p> Source code in <code>src/nats_contrib/request_many/iterator.py</code> <pre><code>def __aiter__(self) -&gt; RequestManyIterator:\n    \"\"\"RequestManyIterator is an asynchronous iterator.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/nats_contrib/request_many/#nats_contrib.request_many.RequestManyIterator.__anext__","title":"<code>__anext__()</code>  <code>async</code>","text":"<p>Return the next message or raise StopAsyncIteration.</p> Source code in <code>src/nats_contrib/request_many/iterator.py</code> <pre><code>async def __anext__(self) -&gt; Msg:\n    \"\"\"Return the next message or raise StopAsyncIteration.\"\"\"\n    if not self._sub:\n        raise RuntimeError(\n            \"RequestManyIterator must be used as an async context manager\"\n        )\n    # Exit early if we've already unsubscribed\n    if self._did_unsubscribe:\n        raise StopAsyncIteration\n    # Exit early if we received all the messages\n    if self.max_count and self._total_received == self.max_count:\n        if self._sub and not self._did_unsubscribe:\n            self._did_unsubscribe = True\n            await _unsubscribe(self._sub)\n        raise StopAsyncIteration\n    # Create a task to wait for the next message\n    task: asyncio.Task[Msg] = asyncio.create_task(self._iterator.__anext__())  # type: ignore\n    self._pending_task = task\n    # Wait for the next message or any of the other tasks to complete\n    await asyncio.wait(\n        [self._pending_task, *self._tasks],\n        return_when=asyncio.FIRST_COMPLETED,\n    )\n    if self._pending_task.cancelled():\n        raise StopAsyncIteration\n    if not self._pending_task.done():\n        self._pending_task.cancel()\n        raise StopAsyncIteration\n    # if err := self._pending_task.exception():\n    #     raise err\n    # This will raise an exception if an error occurred within the task\n    msg = self._pending_task.result()\n    # Always increment the total received count\n    self._total_received += 1\n    # Check if this is a sentinel message\n    if self.stop_on_sentinel and msg.subject == \"sentinel\":\n        if self._sub and not self._did_unsubscribe:\n            self._did_unsubscribe = True\n            await _unsubscribe(self._sub)\n        # In which case, raise StopAsyncIteration and don't return the message\n        raise StopAsyncIteration\n    # Return the message\n    return msg\n</code></pre>"},{"location":"reference/nats_contrib/request_many/#nats_contrib.request_many.RequestManyIterator.__init__","title":"<code>__init__(nc, subject, inbox, payload=None, headers=None, max_wait=None, max_interval=None, max_count=None, stop_on_sentinel=False)</code>","text":"<p>Request many responses from the same subject.</p> <p>Request is sent when entering the async context manager and unsubscribed when exiting.</p> <p>The async iterator yieled by the context manager do not raise an error when no responses are received.</p> <p>Responses are received until one of the following conditions is met:</p> <ul> <li>max_wait seconds have passed.</li> <li>max_count responses have been received.</li> <li>max_interval seconds have passed between responses.</li> <li>A sentinel message is received and stop_on_sentinel is True.</li> </ul> <p>When any of the condition is met, the async iterator raises StopAsyncIteration on the next call to anext, and the subscription is unsubscribed on exit.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>The subject to send the request to.</p> required <code>payload</code> <code>bytes | None</code> <p>The payload to send with the request.</p> <code>None</code> <code>headers</code> <code>dict[str, str] | None</code> <p>The headers to send with the request.</p> <code>None</code> <code>inbox</code> <code>str</code> <p>The inbox to receive the responses in. A new inbox is created if None.</p> required <code>max_wait</code> <code>float | None</code> <p>The maximum amount of time to wait for responses. Default max wait can be configured at the instance level.</p> <code>None</code> <code>max_count</code> <code>int | None</code> <p>The maximum number of responses to accept. No limit by default.</p> <code>None</code> <code>max_interval</code> <code>float | None</code> <p>The maximum amount of time between responses. No limit by default.</p> <code>None</code> <code>stop_on_sentinel</code> <code>bool</code> <p>Whether to stop when a sentinel message is received. False by default.</p> <code>False</code> Source code in <code>src/nats_contrib/request_many/iterator.py</code> <pre><code>def __init__(\n    self,\n    nc: Client,\n    subject: str,\n    inbox: str,\n    payload: bytes | None = None,\n    headers: dict[str, str] | None = None,\n    max_wait: float | None = None,\n    max_interval: float | None = None,\n    max_count: int | None = None,\n    stop_on_sentinel: bool = False,\n) -&gt; None:\n    \"\"\"Request many responses from the same subject.\n\n    Request is sent when entering the async context manager and unsubscribed when exiting.\n\n    The async iterator yieled by the context manager do not raise an\n    error when no responses are received.\n\n    Responses are received until one of the following conditions is met:\n\n    - max_wait seconds have passed.\n    - max_count responses have been received.\n    - max_interval seconds have passed between responses.\n    - A sentinel message is received and stop_on_sentinel is True.\n\n    When any of the condition is met, the async iterator raises StopAsyncIteration on\n    the next call to __anext__, and the subscription is unsubscribed on exit.\n\n    Args:\n        subject: The subject to send the request to.\n        payload: The payload to send with the request.\n        headers: The headers to send with the request.\n        inbox: The inbox to receive the responses in. A new inbox is created if None.\n        max_wait: The maximum amount of time to wait for responses. Default max wait can be configured at the instance level.\n        max_count: The maximum number of responses to accept. No limit by default.\n        max_interval: The maximum amount of time between responses. No limit by default.\n        stop_on_sentinel: Whether to stop when a sentinel message is received. False by default.\n    \"\"\"\n    if max_wait is None and max_interval is None:\n        max_wait = 0.5\n    # Save all the arguments as instance variables.\n    self.nc = nc\n    self.subject = subject\n    self.payload = payload\n    self.headers = headers\n    self.inbox = inbox\n    self.max_wait = max_wait\n    self.max_count = max_count\n    self.max_interval = max_interval\n    self.stop_on_sentinel = stop_on_sentinel\n    # Initialize the state of the request many iterator\n    self._sub: Subscription | None = None\n    self._iterator: AsyncIterator[Msg] | None = None\n    self._did_unsubscribe = False\n    self._total_received = 0\n    self._last_received = asyncio.get_event_loop().time()\n    self._tasks: list[asyncio.Task[object]] = []\n    self._pending_task: asyncio.Task[Msg] | None = None\n</code></pre>"},{"location":"reference/nats_contrib/request_many/#nats_contrib.request_many.transform","title":"<code>transform(source, map)</code>","text":"<p>Create a new async context manager which will yield an async iterator that applies the map function to each value yielded by the source async iterator.</p> <p>It is useful for example to transform the return value of the <code>request_many_iter</code> method.</p> Source code in <code>src/nats_contrib/request_many/utils.py</code> <pre><code>def transform(\n    source: AsyncContextManager[AsyncIterator[T]],\n    map: Callable[[T], R],\n) -&gt; AsyncContextManager[AsyncIterator[R]]:\n    \"\"\"Create a new async context manager which will\n    yield an async iterator that applies the map function to each value\n    yielded by the source async iterator.\n\n    It is useful for example to transform the return value of the\n    `request_many_iter` method.\n    \"\"\"\n    return TransformAsyncIterator(source, map)\n</code></pre>"}]}